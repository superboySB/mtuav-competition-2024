现在我需要大改整个策略，为了更加高效，我们需要全面放弃“特定飞机、特定车、特定卸货点、特定起飞点“的永久绑定，改为动态的走点请你帮我做如下改动：
1. self.__init__里面保留self.fixed_paths_start_to_key_point ，但是里面的值已经被我修改self.fixed_paths_start_to_key_point = {
            "SIM-MAGV-0001": [
                [(183,434), (183,439), (187,439)]
            ],
            "SIM-MAGV-0002": [
                [(190,438), (190,439), (193,439)]
            ],
            "SIM-MAGV-0003": [
                [(183,446), (183, 445), (187,445)]
            ],
            "SIM-MAGV-0004": [
                [(197,434), (199,434), (199,439)]
            ],
            "SIM-MAGV-0005": [
                [(190,444), (190,445), (193,445)]
            ],
            "SIM-MAGV-0006": [
                [(197,446), (197, 445), (199,445)]
            ],
        }
保留MOVE_CAR_TO_DRONE_KEY_POINT这样的状态，一开始让各个小车移动到一个比较容易后续展开工作的初始位置。

2. 删除self.car_initial_positions（因为self.fixed_paths_start_to_key_point中各个车的第一个元素就是其实就是出生点）。删除self.given_car_drone_key_point、self.given_car_unloading_point、self.current_altitude_levels_for_cars，因为我们不需要再和车进行key value绑定的笨蛋策略。引入一个self.take_off_point = [190,431]，作为所有飞机公共的起飞点。引入self.drone_delivery_fly_height_dict，里面有六个key，分别为[146,186]，[528,172], [564,394], [430,184], [490,390],[508,514]这六个外卖点坐标，value均设为-115吧，意思是无人机送这六个地方的外卖都从统一的self.take_off_point起飞、平飞高度都是115。引入六个降落点self.landing_points = [(187,439), (193,439), (187,445),(199,439), (193,445),(199,445)]，引入self.drone_return_fly_height_dict，里面有六个key，分别为[146,186]，[528,172], [564,394], [430,184], [490,390],[508,514]这六个外卖点坐标，value分别为-115、-115、-85、-105、-85、-75这六个高度，意思是无人机从六个地方的外卖回来时的平飞高度。引入self.drone_return_landing_point_dict，里面有六个key，分别为[146,186]，[528,172], [564,394], [430,184], [490,390],[508,514]这六个外卖点坐标，value分别(187,439), (193,439), (187,445),(199,439), (193,445),(199,445)这六个降落点坐标，意思就是这些外卖点上已经送完外卖的无人机返程的时候分别去这六个降落点，相当不再用车的id绑定了，而是点对点绑定，让车灵活调配。

3. 删除复杂的self.fixed_paths_key_point_to_loading，不再让车辆绑定具体路径，而是采用内圈和外圈两套waypoints，让车辆在内圈外圈的关键点进行六个降落点的灵活补位，self.outer_cycle_waypoints = [(181,445), (181,425), (190, 425), (190, 431), (199,431), (199, 439), (199,445), (193, 445), (187,445), (181, 445)]，self.inner_cycle_waypoints = [(185,439), (185,425), (190, 425), (190, 431), (199, 431), (199, 439), (193, 439), (187, 439), (185, 439)]，很显然这两个cycle都是有向的一个循环，并且包含了很多公共的点，其中(190, 425)是地图唯一的drone移动到小车、以及货物装到飞机上的点，(190, 431)是地图唯一的起飞点，显然outer_cycle_waypoints包含了self.landing_points中的4个；inner_cycle_waypoints包含了self.landing_points中的3个。两边的小车都按照外圈或者内圈的轨迹完成主函数整个一个状态的切换，waypoint之前类似之前self.fixed_paths_key_point_to_loading的用法进行逐段的路径规划，并且可以简化self.plan_path_avoiding_obstacles的复杂度了（应该可以避免使用占用区域、预定义路径等做法），因为可以让外圈的小车和内圈的小车就依次沿着下一个点移动就好，冲突避免规则可以改进为：如果小车发现自己的下一个waypoint还有另一个小车占用，就等待即可。这里还有一个问题就是内圈、外圈的交点恰好是一个降落点(199,439)，此时到达这个点的小车可以决定是接下来沿着内圈、还是外圈，我们直接数当前内圈降落点（3个）上的驻扎小车个数和外圈降落点（4个）的驻扎小车个数，哪个如果现在比较少，就让这个小车去哪个。

4. 删除self.waybill_dict[drone_sn]这样呆板的预定义操作代码，self.select_best_order里面应该不需要drone_sn作为入参了，直接遍历self.bills_status，已知订单的生成时间戳ordertime还是按照订单编号从小变大的，所以策略可以改为先看当前available_orders里面，betterTime最晚的那个外卖的betterTime-current_time是否还能不少于120秒，如果是，就送这一单，如果不是，就放弃这些外卖，考虑订单是随着时间不断生成的、也就是current_time之后若干秒一定有订单生成，则盯着未来最近的这个外卖，程序里标记一下盯是哪个外卖，然后打印我现在关注的外卖的bill_status.index、orderTime、betterTime、timeout以及current_time、还有orderTime-current也就是还有多少时间能看到这个外卖并且开始送，然后可以先return None，让其它小车能够继续移动。如果订单生成了，就开始送这单。

5. 为了让你更加专注的修改我出问题的代码，我在前面的源码里省略了self.sys_init()的复杂实现，但是你不要在def running(self):里面删去这个self.sys_init()的调用，它涉及一些预计算，我还有用。

请你理解我上述的需求，帮我实现到目前的代码中，并给我改后的完整代码。注意不要修改和我上面让你改进的地方无关的代码和注释。






--------------------------------------------
在帮我改几个地方

第一，再检查一下车辆路径规划的代码，确定final_destination和current_waypoint_index的使用是否正确（比如我觉得final_destination很多余），请你注意到内圈和外圈是循环的，并且已经涵盖了小车每一个状态下要到的地方，所以冲突避免是不是也可以简单一点，就每个小车避障、以及避开其它小车的时候，如果其它小车静止也就是car_ready，就算它自身xy周围3的范围为禁止区域；如果其它小车正在移动，就把它的起始和终点waypoint周围3的范围设为禁止区域。只要当前小车在当前cycle里面下一个waypoint落在了禁止区域，就不要移动。很显然，内外圈是可以同时往前推进的。

第二，外圈的四个降落点中，最左侧的是（187,445）；内圈的三个降落点中，最左侧的是（187,439），内外圈的小车只有驮着已经降落的飞机，才可以成功分别通过（187,445）或者（187,439），否则就需要等待。如果此时有飞机将外卖送达，并且准备返航，则根据self.drone_return_fly_height_dict的高度下选择目标降落点的优先级为（187,439）、（187,445）（193,439）、（193,445）、（199,445）、（199,439），如果高优先级的降落点被占用了，就选择低优先级的，取消drone_return_landing_point_dict。注意，我们占用的都是具体的点，而不是小车，小车是动态移动的。也就是说，如果当前小车已经接到了飞机，它就可以在没有冲突的情况下向前面waypoint直接前进；如果当前小车没有接到飞机，但是左侧如果有其它降落点（优先级更高）、并且这个降落点上没有小车（可能已经接到飞机走了），则它也可以在没有冲突的情况下向前面waypoint直接前进（即移动到这个降落点、让后面的小车移动到自己的位置）。一句话就是，我需要你实现内外圈的一种“自动补位”的机制，同时还要避免冲突。

请你理解我上述的需求，帮我实现到目前的代码中，并给我改后的完整代码。注意不要修改和我上面让你改进的地方无关的代码和注释。

----------------------------------------

