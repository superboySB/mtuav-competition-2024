你是一个代码大师，现在我想一点点改进一下，首先我看到def running(self):里面每一次其实控制的都是车的列表里的第一个和无人机列表里的第一个car_sn = self.car_sn_list[0] 
        drone_sn = self.drone_sn_list[0]，但实际上，无人机和无人车都有多个（无人机多于无人车），这样写一直是一个无人车和一个无人机在动，浪费太多资源。能不能先看一下无人车数量（比如N），然后把N个无人机一一对应在这些无人车上（需要绑定），每一次规划N对 无人车和无人机？

此外，这里面还可能有一些可能产生冲突的点，需要你帮忙改进，列举如下：

- 第一个，这个地图装载点（也是更换电池的点）只有一个，也就是loading_pos = Position(
                self.loading_cargo_point['x'],
                self.loading_cargo_point['y'],
                self.loading_cargo_point['z'])。而任务要求无人车的安全距离5米，任意两个无人车在任意时刻只要3D距离小于5米就视为相撞、直接在任务中消失并且我会承担惩罚。然而，我ros发送车辆行为指令后，就不可以更改，所以必须在每个小车做行为之前就先判断才可以。总之，我想避免这些无人车在取货或者给飞机换电的时候相撞。此外，小车要在航空作业区才能接飞机降落，任何一点都可以进行航空作业。需要注意的是，小车的位置不要太靠近边界，因为有可能会被误判出界，一般保持0.5米左右的距离就行如果有可能还会有其它情况造成小车之间相撞的情况，如果有我没有考虑到的，请你进行补充。

- 第二个，无人机的安全距离10米，并且只能飞在60-120米的高空上（也就是drone_pos.z要在-60到-120之间，我代码里给的-145只是一个例子，其实是不合法的高度）。注意：降落到距离很近的位置也会判定为相撞，也就是降落的时候降落点不能有其他无人机，任意两个无人机在任意时刻只要3D距离小于10米就视为相撞、直接在任务中消失并且我会承担惩罚。然而，我ros发送飞机航线指令后，就不可以更改，所以必须在每个飞机做行为之前就先判断才可以。这里面我有一个朴素的思路就是将空域分成-60、-70、-80、-90、-100、-110、-120七个部分，假设小车数量N不会大于7，每一对小车和飞机优先从从-120开始安排高度，安排到-60，保证各个飞机在平飞期间绝大多数时候不会撞上。然而，飞机还是有可能会在起飞、降落的时候撞上，这时候需要给不同小车上的飞机加降落点的判断，保证前一个飞机以及开始飞了，那么就暂时放弃落点在它降落区域10米内的订单，避免后续飞机和这个飞机有冲突。如果有可能还会有其它情况造成飞机之间相撞的情况，如果有我没有考虑到的，请你进行补充。

- 第三，我有很多rospy.sleep的操作，我希望你还是尽量保留，但是最好是给出sleep时间时间的同时，还建议通过panoramic_info_callback这个回调函数获取实时信息，从而可以加上小车和飞机的状态来判断，或者判断是否会重复拿外卖，避免有时候ros网络延迟、造成一些系统错误。

- 第四，除了飞机之间的冲突，其实空中还会有一些大楼作为障碍物，飞机也需要躲避。这里你可以使用一个预先给60、70、80、90、100、110、120高度均建立一个相应的障碍物地图的思想，构建一个self.occ_map_dict的字典，key应该是高度。然后考虑到这个任务背后有一个体素地图，可以调用request = QueryVoxelRequest()
        request.x = 1.0
        request.y = 2.0
        request.z = -3.0
这样的用法，在七种不同的request.z取值下，每一个高度相应的地图都双重采样request.x从0到max_x，request.y从0到max_y，具体max_x和max_y可以先用self.map_boundary = self.config['taskParam']['mapBoundaryInfo']，它里面的内容示例如下{
            "bottomLeft": {
                "x": 100,
                "y": 100,
                "z": 0
            },
            "bottomRight": {
                "x": 600,
                "y": 100,
                "z": 0
            },
            "heightLimit": 10,
            "lowLimit": -120,
            "topLeft": {
                "x": 100,
                "y": 600,
                "z": 0
            },
            "topRight": {
                "x": 600,
                "y": 600,
                "z": 0
            }
        }你不要直接用里面的数字，而是用相应的属性、变量来表示，防止换了一张地图你这代码就不apply了。然后，response = self.map_client(request)会返回一些属性，其中response.distance 代表当前体素距离障碍物的最近距离，<=0 的区域代表本身就是障碍物，我们给一些控制上的余量，认为response.distance<2的体素就是障碍物，response.distance>=2的体素认为是空气（可以通行）。此外，response.semantic会输出一些整数，我们关注response.semantic=255的情况就行，因为这样表示这个位置其实在地图外了，可以用这种方式减少request.x、request.y遍历的范围，最终构建7个不同高度的有效的障碍物地图。我们可以专门在test_map_query附近的位置做一个这样的功能，但是也要在整个代码的def __init__(self):加上一个self.need_init的变量。这样的好处是：如果我设置self.need_init为true，我就专心建图，然后把建图结果self.occ_map_dict保存到一个本地文件，然后就结束这个程序，可以用WorkState为FINISHED，提示建图完成；如果我设置self.need_init为false，那我就从相应的本地文件读取这个建图结果到self.occ_map_dict，让我再在这个任务区域做事情的时候可以不用重复建图。

第五，我发现你没有用到这个变量self.unloading_cargo_stations = self.config['taskParam']['unloadingCargoStationList']，它应该是一个列表，范例内容如下
[
            {
                "index": 1,
                "name": "测试卸货点1",
                "position": {
                    "x": 146,
                    "y": 186,
                    "z": -34
                }
            },
            {
                "index": 2,
                "name": "测试卸货点2",
                "position": {
                    "x": 430,
                    "y": 184,
                    "z": -10
                }
            },
            {
                "index": 3,
                "name": "测试卸货点3",
                "position": {
                    "x": 528,
                    "y": 172,
                    "z": -20
                }
            },
            {
                "index": 4,
                "name": "测试卸货点4",
                "position": {
                    "x": 508,
                    "y": 514,
                    "z": -22
                }
            },
            {
                "index": 5,
                "name": "测试卸货点5",
                "position": {
                    "x": 564,
                    "y": 394,
                    "z": -16
                }
            },
            {
                "index": 6,
                "name": "测试卸货点6",
                "position": {
                    "x": 490,
                    "y": 390,
                    "z": -22
                }
            }
        ]
你不要直接用里面的数字，而是知道里面大概的格式就行。也就是说，所有外卖要送到的地方只有6种可能性。因此，在你拥有self.occ_map_dict、并且self.need_init为false的前提下，肯定用这个self.occ_map_dict来优化每一层空域下无人机的避障能力，此时如果是在线使用A star算法去搜索全局最优的路径可能会在一个大地图里面变得非常缓慢。考虑到我规划飞机都是使用route = [start_pos, middle_pos, end_pos]，此处middle_pos可以不只是这一个，而不同的pos之间是先加速、再匀速、再减速的方式，因此应该避免太多的middle_pos，从而提高送餐速度，这就跟常规A star给出的最优避障路径是冲突的。我觉得这里可以引入快速通道的思路，建立一个self.fast_path_dict给不同的空域，key依然可以是高度，然后每一个value里面存这个高度下所有起点、落点之间可以直线到达的快速路径，肯定是需要大量暴力采样起点、终点得到；然后把它也作为self.need_init在建图之后要做的事情，结果也保存在本地，同样地，如果self.need_init为false就应该只需要导入相应信息就行、毕竟这个很耗时。总之，这样子的话，我们就可以大大提高A star给出最优路径的速度，使得start_pos和end_pos之间尽量有最少的middle_pos、然后我们再尽可能满足一个飞行路径总长度最小的目标，达到一个又快又好、以存代算的目的。实现上述方案以后，我们应该可以让飞机学会避障了。

请你结合我的完整代码，不要遗漏要求地实现我上述想法、解决我的上述问题。因为我用git管理，注意尽量保留我重要的注释，只改进你觉得需要改进的地方。